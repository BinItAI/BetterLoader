(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{73:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return o})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return d}));var n=a(2),s=a(6),r=(a(0),a(82)),i={id:"gettingstarted",title:"Getting Started",sidebar_label:"Getting Started",slug:"/"},o={unversionedId:"gettingstarted",id:"gettingstarted",isDocsHomePage:!1,title:"Getting Started",description:"Installation",source:"@site/docs/gettingstarted.md",slug:"/",permalink:"/BetterLoader/docs/",editUrl:"https://github.com/binitai/BetterLoader/docs/gettingstarted.md",version:"current",sidebar_label:"Getting Started",sidebar:"someSidebar",next:{title:"Index & Subset Files",permalink:"/BetterLoader/docs/files"}},l=[{value:"Installation",id:"installation",children:[{value:"Python",id:"python",children:[]},{value:"From Source",id:"from-source",children:[]}]},{value:"Usage",id:"usage",children:[{value:"Basic Usage",id:"basic-usage",children:[]},{value:"Constructor Parameters",id:"constructor-parameters",children:[]}]}],c={rightToc:l};function d(e){var t=e.components,a=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"installation"},"Installation"),Object(r.b)("h3",{id:"python"},"Python"),Object(r.b)("p",null,"The BetterLoader library is hosted on ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://pypi.org/"}),"pypi")," and can be installed via ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://pip.pypa.io/en/stable/"}),"pip"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-bash"}),"pip install betterloader\n")),Object(r.b)("h3",{id:"from-source"},"From Source"),Object(r.b)("p",null,"For developers, BetterLoader's source may also be found at our ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/BinItAI/BetterLoader"}),"Github repository"),". You can also install BetterLoader from source, but if you're just trying to use the package, pip is probably a far better bet."),Object(r.b)("h2",{id:"usage"},"Usage"),Object(r.b)("p",null,"BetterLoader really shines when you're working with a dataset, and you want to load subsets of image classes conditionally. Say you have 3 folders of images, and you only want to load those images that conform to a specific condition, ",Object(r.b)("b",null,"or")," those that are present in a pre-defined subset file. What if you want to load a specific set of crops per source image, given a set of source images? BetterLoader can do all this, and more.",Object(r.b)("br",null)),Object(r.b)("b",null,"Note:")," BetterLoader currently only supports supervised deep learning tasks. Unsupervised learning support coming soon!",Object(r.b)("h3",{id:"basic-usage"},"Basic Usage"),Object(r.b)("p",null,"Using BetterLoader with its default parameters lets it function just like the regular Python dataloader. A few points worth noting are that:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"BetterLoader does not expect a nested folder structure. In its current iteration, files are expected to all be present in the root directory. This lets us use index files to define classes and labels dynamically, and vary them from experiment to experiment."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("b",null,"Every")," instance of BetterLoader requires an index file to function. The default index file format maps class names to a list of image paths, but the index file can be any json file as long as you modify train_test_val_instances to parse it correctly; for example you could instead map class names to regex for the file paths and pass a train_test_val_instances that reads the files based on that regex. Sample index files may be found ",Object(r.b)("a",{href:"/docs/files"},"here"),".")),Object(r.b)("p",null,"A sample use-case for BetterLoader may be found below. It's worth noting that at this point in time, the BetterLoader class has only one callable function."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),'from betterloader import BetterLoader\n\nindex_json = \'./examples/sample_index.json\'\nbasepath = "./examples/sample_dataset/"\nbatch_size = 2\n\nloader = BetterLoader(basepath=basepath, index_json_path=index_json)\ndataloaders, sizes = loader.fetch_segmented_dataloaders(batch_size=batch_size, transform=None)\n\nprint("Dataloader sizes: {}".format(str(sizes)))\n')),Object(r.b)("h3",{id:"constructor-parameters"},"Constructor Parameters"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"field"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"type"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:"right"}),"description"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:"right"}),"optional (datatype)"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"basepath"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"str"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"path to image directory"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"no")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"index_json_path"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"str"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"path to index file"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"no")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"num_workers"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"int"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"number of workers"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"yes (1)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"subset_json_path"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"str"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"path to subset json file"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"yes (None)")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"dataset_metadata"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"metadata object for dataset"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"list of optional metadata attributes to customise the BetterLoader"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"right"}),"yes (None)")))),Object(r.b)("h4",{id:"dataset-metadata"},"Dataset Metadata"),Object(r.b)("p",null,"BetterLoader accepts certain key value pairs as dataset metadata, in order to enable some custom functionality."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"pretransform (callable, optional): This allows us to load a custom pretransform before images are loaded into the dataloader and transformed.\nFor basic usage a pretransform that does not do anything (the default) is usually sufficient. An example use case for the customizability is listed below."),Object(r.b)("li",{parentName:"ol"},"classdata (callable, optional): Defines a custom mapping for a custom format index file to read data from the DatasetFolder class.\nSince the index file may have any structure we need to ensure that the classes and a mapping from the classes to the index are always available.\nReturns a tuple (list of classes, dictionary mapping of class to index)"),Object(r.b)("li",{parentName:"ol"},"split (tuple, optional): Defines a tuple for train, test, val values which must add to one."),Object(r.b)("li",{parentName:"ol"},"train_test_val_instances (callable, optional): Defines a custom function to read values from the index file.\nThe default expects an index that is a dict mapping classes to a list of file paths, will need to be written custom for different index formats.\nAlways must return train test and val splits, which each need to be a list of tuples, each tuple corresponding to one datapoint.\nThe first element of this tuple must also be the filepath of the image for that datapoint.\nThe default also has the target class index as the second element of this tuple, this is probably good for most use cases.\nEach of these datapoint tuples is passed as the ",Object(r.b)("inlineCode",{parentName:"li"},"values")," argument in the pretransform, any additional data necessary for transforming the datapoint before it is loaded can go in the datapoint tuple.")),Object(r.b)("hr",null),Object(r.b)("p",null,"Here is an example of a ",Object(r.b)("inlineCode",{parentName:"p"},"pretransform")," and a ",Object(r.b)("inlineCode",{parentName:"p"},"train_test_val_instances")," designed to allow for a specified crop to be taken of each image. The internals of the loader dictate that the elements of the ",Object(r.b)("inlineCode",{parentName:"p"},"instances")," variable from train_test_val_instances will become the ",Object(r.b)("inlineCode",{parentName:"p"},"values")," argument for pretransform, and the ",Object(r.b)("inlineCode",{parentName:"p"},"sample")," argument for pretransform is the image data loaded directly from the filepath in ",Object(r.b)("inlineCode",{parentName:"p"},"values[0]")," (or ",Object(r.b)("inlineCode",{parentName:"p"},"instances[i][0]"),")."),Object(r.b)("p",null,"Since the index file here has a similar structure to the default we can get away with using the default classdata function, but index files that don't have the classes as keys of a dictionary will need a custom way of determining the classes."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),'def pretransform(sample, values):\n    """Example pretransform\n    takes an image and crops it based on the parameters defined in values[2]\n    """\n    image_path = values[0] #this is unused, but the image path is always values[0]\n    target = values[1]\n    crop_params = values[2]\n    \n    cropped_sample = some_crop_function(sample,crop_params)\n    \n    #the return should always have this structure (some image data, some target class index)\n    return (cropped_sample,target)\n    \n')),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),'def train_test_val_instances(split, directory, class_to_idx, index, is_valid_file):\n    """Example train/test/val instance creation on a dataset where each image requires a unique specific crop.\n    For each class loops through the associated image paths, and adds a tuple of (the path, the class index) to the instances list.\n    Then the instances list is segmented into train test and val splits.\n    Args:\n        split (tuple): Tuple of ratios (from 0 to 1) for train, test, val values\n        directory (str): Parent directory to read images from\n        class_to_idx (dict): Dictionary to map values from class strings to index values\n        index (dict): Index file dict object\n        is_valid_file (callable): Function to verify if a file should be loaded\n    Returns:\n        (tuple): Tuple of length 3 containing train, test, val instances\n    """\n    train, test, val = [], [], []\n    i = 0\n    for target_class in sorted(class_to_idx.keys()):\n        i += 1\n        if not os.path.isdir(directory):\n            continue\n        instances = []\n        for params in index[target_class]:\n            file = params[\'file_path\']\n            crop_params = params[\'crop\']\n            if is_valid_file(file):\n                path = os.path.join(directory, file)\n                #the path to the image must always be the first parameter in the instances; everything else is optional\n                instances.append((path, class_to_idx[target_class],crop_params))\n\n        trainp, _, valp = split\n\n        train += instances[:int(len(instances)*trainp)]\n        test += instances[int(len(instances)*trainp):int(len(instances)*(1-valp))]\n        val += instances[int(len(instances)*(1-valp)):]\n    return train, test, val\n')))}d.isMDXComponent=!0}}]);